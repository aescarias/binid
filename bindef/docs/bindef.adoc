= The BinDef Language Reference
√Ångel Carias <lotta.dev@outlook.com>
v0.5, 2025-12-16
:toc: auto
:sectnums: |,all|

WARNING: This document describes a format that is in early development. Many things are currently undocumented, unimplemented, and are bound to change. 

== What is BinDef?

The BinDef (Binary Definition) language is a declarative language for describing a binary file format. BinDef provides abstractions for validating magic signatures, reading structures, dealing with endianness, and more, under a simple JSON-like format. 

BinDef was created for use with the file identification tool BinID allowing this tool to be extensible. While describing a binary format in an imperative language such as C or Go (which the reference BinDef implementation uses) is definitely possible, the objective of the BinID tool makes this task tiresome as similar patterns and boilerplate emerge.

Hence, the need was born for a simple language like BinDef that allows developers to quickly describe the contents of a file format.

== Comments

Comments allow definition authors to embed annotations or explanations within the definition file. Comments have no syntactical meaning and are ignored by the runtime.

BinDef supports _line comments_ and _block comments_.

Line comments start with `//` and extend to the end of line.

[source,javascript]
----
// this is a comment
{
  meta: {
    bdf: "0.1" // comments can also appear here
  }
}
----

NOTE: Block comments were added in version 0.2

Block comments start with `/*` and extend to the end of the first `*/` found. Block comments can hence span multiple lines and occur anywhere within a BinDef document.

[source,javascript]
----
/* this is a block comment 
   that spans multiple lines
*/
{
  meta: {
    /* it may appear here */
    bdf: /* or even here */ "0.1"
  }
}
----

== Data Types

BinDef has the following data types:

- Strings
- Identifiers
- Booleans
- Integers
- Floats
- Lists
- Mappings
- Lazy Expressions

=== Strings

Strings are sequences of Unicode code points that start and end with a single quote (`'`) or a double quote (`"`).

[source,javascript]
----
"Hello, world!"
"I'm a string!"
"This is a palm tree: üå¥"
----

A string must start and end with the same quote, so expressions such as `'hello world"` are not allowed.

A string may span multiple lines.

[source,text]
----
"
Hello, world!
This string is many lines long.
"
----

==== Escape Sequences

A string may contain the following escape sequences.

- `\\` inserts a backslash (`\`).
- `\'` inserts a single quote (`'`).
- `\'` inserts a double quote (`"`).
- `\n` inserts a newline.
- `\r` inserts a carriage return.
- `\t` inserts a horizontal tab.
- `\xhh` inserts a character with the hexadecimal code `hh`.
- `\ooo` inserts a character with the octal code `ooo`.

Usage of an unknown escape sequence will result in an error.

=== Booleans

Booleans in BinDef are supported via the `true` and `false` identifiers.
[source,javascript]
----
true false
----

=== Integers

Integers consist of a sequence of digits representing a numeric value. The range of values that may be represented by an integer may depend on the internals of the interpreter but this range shall be enough to hold anything within the 64-bit signed integer limit.

[source,javascript]
----
1000
----

NOTE: The reference implementation does not define an integer limit as it uses arbitrary-precision integers.

A number may include a leading sign bit (+ or -). 

[source,javascript]
----
-1000
+2000
----

A number may not start with a leading zero.

[source,javascript]
----
01000 // invalid
----

To aid readability, underscore (`_`) characters may appear anywhere within the numeric sequence.

[source,javascript]
----
1_000_000
----

==== Base-Prefixed Integers

Certain integer values may be better expressed using a different notation. BinDef supports this via base-prefixed integers which start with a `0` followed by one of the following characters:

- `b`: The sequence of digits is interpreted in binary (base 2).
- `o`: The sequence of digits is interpreted in octal (base 8).
- `x`: The sequence of digits is interpreted in hexadecimal (base 16).

[source,javascript]
----
0b10100  //  20 in decimal
0o755    // 493 in decimal
0xff     // 255 in decimal
----

Underscore characters must appear after the base prefix.

=== Floats

Floating point numbers, or floats, consist of a sequence of digits separated by a period (`.`). 

[source,javascript]
----
2.71828
3.14159
----

The range of values that a float may represent shall be enough to hold anything within the double-precision floating point format.

Leading or trailing periods within a floating point number are not allowed.

[source,javascript]
----
.10 // invalid
0.  // invalid
1.2 // valid
----

Like integers, floats may also have a sign bit.

[source,javascript]
----
-2.71828
+3.14159
----

=== Identifiers

Identifiers consist of a sequence of characters and are effectively atomic values that may be interpreted differently depending on context (in some cases, they are interpreted as a *format type* or as a *reference* within the structure).

An identifier shall be formed of one or more alphanumeric characters, that is, any character within the range A-Z, a-z, and 0-9. The underscore character (`_`) and minus sign (`-`) are also allowed within an identifier.

[source,javascript]
----
this_is_an_identifier 
thisIdentifies
this-also-identifies
----

Identifiers may not start with a decimal digit or with the minus sign (`-`).

=== Mappings

Mappings are key-value pairs and represent the core structure of a BinDef document. A mapping begins with a _left brace_ `{` and ends with a _right brace_ `}`. The key and value in the pair are separated by a colon and each pair in the mapping is separated by a comma. 

[source,javascript]
----
{
  foo: 1,
  bar: 2,
  baz: 3
}
----

The key and value may be any valid data type.

=== Lists

Lists are ordered collections of elements. A list may contain any amount of items of any valid type.

The elements of a list are enclosed in brackets (`[]`) and each element is separated by a comma (`,`)

[source,javascript]
----
[
    1, 
    "hello", 
    world, 
    ["a", "list"],
    { a: "map" }
]
----

=== Lazy Expressions

Lazy expressions are types containing operations that are lazily evaluated, that is, computed when accessing the structure including them rather than during interpretation.

This lazy evaluation applies to operations requiring namespace access. A namespace is a mapping of names which is generated by the language runtime from the BinDef document. The keys of a mapping conforming a namespace shall be identifiers.

The following expressions are considered _lazy_:

- Attribute access (`foo.bar`)
- Function calls (`foo(bar)`)
- Subscripts (`mapping[key]`, `list[index]`, and `type[param]`)
- Identifiers (`bar`, `baz`)

Binary or unary operations that include operands meeting these conditions are also considered lazy. 

Identifiers are considered lazy as their processing is context-aware. Within BinDef, an identifier can represent both an assignment and a reference within a namespace. The only identifiers not considered lazy are those identifying *format types*, which are described in <<Format types>>.

Lazy expressions shall always appear as a single expression and must not be an operand of another expression. For example, `(a + b) / (c + d)` does not produce the division of two lazy expressions but rather a lazy expression containing the division of the evaluated operands.

[source,javascript]
----
// to evaluate this, the namespace "foo" must exist and have a member "bar"
foo.bar + 2
// function calls and subscript access also need namespace access
foo[bar] + spam(eggs)
// the following expression can be evaluated immediately
2**3 + 1
----

== Unary Operators

A unary operation applies an operation on a single type.

The following unary operators are available:

- Unary minus (`-num`) negates the numeric value following it.
- Unary plus (`+num`) is the same as `num` but is provided for completeness.
- Unary tilde (`~int`) applies the _bitwise complement_ on integer `int`, that is, inverts each bit of the integer.
- Unary not (`!expr`) performs boolean or logical negation to its operand `expr`, converting a truthy value to false and vice versa.

== Binary Operators

A binary operations performs an operation on two types.

The following binary operations are defined:

- Addition (`+`)
- Subtraction (`-`)
- Multiplication (`*`)
- Division (`/`)
- Remainder (`%`)
- Exponentiation (`**`)
- Bitwise left shift (`<<`)
- Bitwise right shift (`>>`)
- Bitwise OR (`|`)
- Bitwise AND (`&`)
- Bitwise XOR (`^`)

=== Addition

If `a` and `b` are numeric types (meaning either integers or floats), `a + b` returns the sum of a plus b. If either operand is a float, the other operand is converted to a float and the resulting value will also be a float.

If `a` and `b` are strings, `a + b` returns the concatenation of the strings `a` and `b`.

Examples are shown below.

[source,javascript]
----
1 + 4 // 5
3.1 + 2 // 5.1
-9 + 7 // -2
"foo" + "bar" // "foobar"
----

=== Subtraction

If `a` and `b` are numeric types, `a - b` returns the subtraction of a and b.

[source,javascript]
----
1 - 4 // -3
5 - 3 // 2
4.5 - 1 // 3.5
----

=== Multiplication

If `a` and `b` are numeric types, `a * b` returns the product of a and b.

[source,javascript]
----
3 * 3    // 9
1.27 * 4 // 5.08
-3 * 2   // -6
----

NOTE: String repetition was added in version 0.3

If `a` is a non-negative integer and `b` is a string, or vice versa, `a * b` produces the concatenation of `a` to itself `b` times.

[source,javascript]
----
3 * "a" // "aaa"
"bar" * 3 // "barbarbar"
----

=== Division

If `a` and `b` are numeric types, `a / b` returns the quotient of a and b.

[source,javascript]
----
200 / 10 // 20
4.3 / 5 // 0.86
----

BinDef does not define division by zero. Performing such operation will result in an error.

The type of the result will be an integer if the quotient can be expressed as a whole number; it will be a float otherwise.

=== Remainder

If `a` and `b` are numeric types, `a % b` returns the remainder of a and b.

[source,javascript]
----
200 % 10 // 0
3.2 % 2  // 1.2
----

The sign bit of the result will be the same as the sign bit of the dividend.

[source,javascript]
----
-3.2 %  2  // -1.2
 3.2 % -2  //  1.2
----

As with division, remainder by zero is not defined.

=== Exponentiation

If `a` and `b` are numeric types, `a ** b` returns the result of base `a` to the power `b`.

[source,javascript]
----
  2 ** 6 // 64
2.5 ** 3 // 15.625
----

BinDef defines the expression `0 ** 0` as 1.

=== Bitwise Operators

Bitwise operators allow performing bit-level operations on integers.

The bitwise operators defined are:

- Bitwise left shift (`<<`)
+
`m << n` shifts the bits of integer `n` `m` places to the left. 

- Bitwise right shift (`>>`)
+
`m >> n` shifts the bits of integer `n` `m` places to the right.

- Bitwise OR (`|`)
+
`x | y` compares two integers `x` and `y`. If either bit x~n~ or y~n~ is set, the resulting bit is 1; otherwise, the resulting bit is zero.

- Bitwise AND (`&`)
+
`x & y` compares two integers `x` and `y`. If both bits x~n~ and y~n~ are set, the resulting bit is 1; otherwise, the resulting bit is zero.

- Bitwise XOR (`^`)
+
`x ^ y` compares two integers `x` and `y`. If either bit x~n~ or y~n~ is set, the resulting bit is 1; otherwise, if both or none of the bits are set, the resulting bit is zero.

=== Comparison Operators

Comparison operators report whether two operators are distinct or equal to each other according to a specified relationship.

The comparison operators defined are:

- Equal to (`==`)
- Not equal to (`!=`)
- Less than (`<`)
- Less than or equal to (`<=`)
- Greater than (`>`)
- Greater than or equal to (`>=`)
- Logical and (`&&`)
- Logical or (`||`)

==== Equal to (`==`) and not equal to (`!=`)

The equality operators `==` and `!=` report whether two operands `a` and `b` are equal to or distinct from each other, respectively.

If `a` and `b` are distinct types, `a == b` will return false and `a != b` will return true.

The next conditions will be explained with the equality operator `==`. The result of the `!=` operator is effectively a negation of the result of `a == b`.

*Numbers:* If `a` and `b` are both integers or both floats, `a == b` is true if the numeric values are equal, and false otherwise.

In the case that `a` is a float and `b` is an integer, `a == b` is true if the truncated floating point value is equal to the integer value, and false otherwise.

*Booleans*: If `a` and `b` are both booleans, `a == b` is true if the operands represent the same boolean, and false otherwise.

*Strings:* If `a` and `b` are both strings, `a == b` is true if the length of the strings are equal and the contents are also equal. If the contents of the strings are distinct, `a == b` will be false. If the length of the strings is not equal, `a == b` will be false regardless of the contents of `a` and `b`.

*Lists*: If `a` and `b` are both lists, `a == b` is true if the length of the lists is equal and the elements, including their order, are also equal. Effectively, for each element a~n~ and b~n~, if a~n~ is distinct from b~n~, then `a == b` is false. If all elements of a and b are equal, `a == b` is true.

*Mappings*: If `a` and `b` are both mappings, `a == b` is true if the amount of keys in the mappings are equal, the mappings contain the same keys (both type and value wise), and the values of each key are the same. The order of the elements is not considered in the comparison.

Effectively, for each element a~key~ and a~value~, b~key~ and b~value~, if a~key~ is distinct from b~key~, then the mappings are assumed to be distinct. If both keys are equal, then if a~value~ is distinct from b~value~, then the mappings are distinct. If all elements of this comparison are true, the mappings are assumed to be equal.

==== Less than, greater than, and their equality variants

The operators `<` and `>` report whether an operand `a` is less than or greater than an operand `b`, respectively. Their variants `<=` and `>=` add an equality component and are practically equivalent to `a < b || a == b` and `a > b || a == b`.

The only types implementing this kind of comparison are integers, floats, and strings. If one of the operands of the comparison is not part of this list, an error shall be raised.

*Numbers:* If `a` and `b` are both integers or both floats, `a < b` is true if the numeric value of `a` is lower than the numeric value of `b`. Likewise, `a > b` is true if `a` is numerically greater than `b`.

In the case that `a` is a float and `b` is an integer, this comparison will be performed using the truncated floating point value as an integer and the other integer value.

*Strings:* If `a` and `b` are both strings, `a < b` is true if `len(a) < len(b)` and, for each element a~n~ and b~n~, the code point value of a~n~ is less than the code point value of b~n~. Similar to equality, a short circuit occurs when `len(a) < len(b)` or `a[n] < b[n]`; in which case, `a < b` is true regardless of the contents of `a` and `b`.

This same process occurs with `a > b` where the result is true if `len(a) > len(b)` and the code point value of a~n~ is greater than the one of b~n~.

=== Logical and (`&&`) and logical or (`||`)

Logical and (`&&`) determines whether two operands `a` and `b` are _truthy_. On the other hand, logical or (`||`) determines whether either of its operands `a` and `b` are _truthy_. Whether a value is truthy or falsy is described in <<Truthiness>>.

For `a || b`, if `a` is truthy, then `b` is not computed and the result is immediately true. 

For `a && b`, if `a` is falsy, then `b` is not computed and the result is immediately false.

=== Ternary Conditions

NOTE: Added in version 0.2

Ternary conditions allow a BinDef runtime to evaluate expressions based on whether a condition was met. 

A ternary condition follows the form `cond ? truthy : falsy` where `cond` is the condition to evaluate, `truthy` is the expression performed if the condition is true, and `falsy` is the operation performed otherwise.

Only the `truthy` part is evaluated if `cond` is true. Likewise, only the `falsy` part if `cond` is false.

=== Truthiness

A value is considered truthy when:

- If boolean, the boolean value is `true`.
- If integer or float, the numeric value is not zero.
- If string, the sequence contains at least one character.
- If list, the sequence contains at least one element.
- If mapping, the mapping contains at least one key-value pair.

A value is considered falsy if it does not meet either of the above conditions.

=== Operator Precedence

From most to least precedence:

- Groupings (`(expr)`) and literals
- Unary plus (`+x`), unary minus (`-x`), unary bitwise complement (`~x`).
- Exponentiation (`**`)
- Multiplication (`*`), division (`/`), remainder (`%`), bitwise left (`<<`), bitwise right (`>>`), bitwise and (`&`)
- Addition (`+`), subtraction (`-`), bitwise or (`|`), bitwise exclusive or (`^`)
- Equal to (`==`), not equal to (`==`), less than (`<`), less than or equal to (`<=`), greater than (`>`), greater than or equal to (`>=`)
- Logical and (`&&`)
- Logical or (`||`)

== The BinDef Document

A BinDef document contains a single mapping describing the binary definition. It is recommended that authors use the `.bdf` extension, and if defining a media or MIME type is necessary, the `text/x-bindef` media type should be used.

For all BinDef defined mappings, it is required that the keys are identifiers.

The single mapping in the document may contain three keys: `meta`, `binary`, and `types`.

- `meta` (required) is a mapping containing metadata or details of the format being described. 
- `binary` (required) is a list of mappings containing the structured description of the format.
- `types` (optional) is a list of mappings containing *format types* that may be used anywhere within `binary`.

NOTE: The `types` key was added in version 0.4

=== The `meta` key

NOTE: Before BinDef 0.5, the keys `mime` and `exts` were required.

`meta` is a mapping containing metadata of the format being described. The keys that the `meta` mapping may contain are:

[cols="1,1,2"]
|====
|Key |Data Type |Value

|bdf 
|string    
|(required) The minimum BinDef version required to parse the file. This string must follow the semantics specified in <<Versioning>>.

|name
|string
|(required) The common name given to the format being described, e.g. "Binary Definition (BinDef) file".

|mime
|list of strings
|(optional) The media or MIME types assigned to the described format. If multiple are listed, they should be listed in descending order of preference.

|exts
|list of strings
|(optional) The file extensions commonly used for this format. If multiple are listed, they should be listed in descending order of preference. The extensions should contain a leading period.

|doc
|string
|(optional) Details regarding the described format. The information that goes here is up to the author, but generally, it should describe the format's purpose, creator(s), and basic structure, and contain links to technical references or specifications.
|====

=== The `binary` key

`binary` is a list of mappings describing the format structure.

Each mapping in the `binary` list is a _format type_ or a _statement_ producing a format type. All format types must contain the `type` key whose value is an identifier for a type.

The currently available types are:

- The unsigned integer types `uint8`, `uint16`, `uint24`, `uint32`, and `uint64`.
- The signed integer types `int8`, `int16`, `int24`, `int32`, and `int64`.
- The floating point types `float32` and `float64`.
- The `byte[n]` type.
- The `array[n]` type.
- The `struct` type.
- The variable definition type `var`.
- The enumeration type `enum`.

Other format types may be defined by including them in the `types` key of the mapping.

If a BinDef processor finds a type that it doesn't recognize, it shall stop parsing the document and issue a warning.

=== The `types` key

`types` is an optional list of mappings describing format types used as type definitions within a BinDef document. The structure of type definitions is discussed in <<Format types>> and <<Type definitions>>.

== Format types

A format type is a mapping describing a field within a structured format such as an integer or a byte sequence. All format types share the following keys:

[cols="1,1,2"]
|====
|Key |Data Type |Value

|type 
|identifier    
|(required) The format type being described. It must be one of the available format types.

|id
|identifier
|(optional) An identifier for this field within the current binary structure.

|name
|string
|(optional) A human-readable title describing the contents of this field.

|doc
|string
|(optional) Information documenting this field such as its purpose or use.

|at
|integer or list of [integer, string]
|(optional) A seek position from which the field will be read.

|valid
|lazy expression
|(optional) A function that validates the contents of the field. If the validation fails, parsing should be stopped and an error should be raised.

|if
|lazy expression
|(optional) A condition for parsing the field. If the condition is met, the field will be parsed; otherwise, it will be skipped.
|====

NOTE: For BinDef versions 0.4 and later, additional considerations apply for format types that appear as type definitions. See <<Type definitions>> for details.

All format types must have a `type` key with an identifier for the format type being used. This also determines whether additional keys may be specified.

The `id` key may contain a name used to identify the value being described. An identifier starting with `_` is considered private and will not appear in the extracted output. If the contents of the field are not relevant (such as with padding or reserved values), the `id` key may be skipped.

The `name` and `doc` keys provide optional documentation for a field. The `name` key is a string intended as a human-readable name of the field. The `doc` key is designed to provide additional information on the purpose of the field or possible values.

=== Seeking

Not every format can be parsed sequentially. Many formats include a header with offsets to different parts of the format structure. To address this, BinDef provides the `at` key which allows a BinDef runtime to _seek_ to a particular byte offset and start parsing fields from that position.

The `at` key may be either an integer or a list of two items. 

* If a single integer, `at` contains the byte offset relative to the start of the file to which the runtime should skip to. 
* If a list, the elements are as follows:
+  
  ** The first item is an integer specifying a byte offset to skip to. 
  ** The second item is either of the following string values: 
    *** `"start"` means the byte offset is relative to the start of the file (the start being byte offset 0).
    *** `"current"` means the byte offset is relative to the current position within the file.
    *** `"end"` means the byte offset is relative to the end of the file. In this case, the byte offset is usually negative.

If the `at` key is not specified, the position from which the field will be read from will be relative to the position of the previously read field. If no field was previously read, the start position assumed is 0. 

`{at: 0}` implies `{at: [0, "current"]}`.

=== Assertions

In many cases, the values of a field are known and expected to be in a set range. To ensure that this is the case when processing the field, BinDef provides *assertions* which allow you to assert that a field matches a condition.

BinDef provides two types of assertions: `valid` assertions and `magic` assertions.

==== `valid` assertions

`valid` assertions are the standard form of assertion and are specified using the `valid` key. Its value shall be a lazily-evaluated expression that returns a boolean determining whether the value contained in the field is correct.

If the expression evaluates to false, then a BinDef runtime should stop parsing the document and should raise an error.

A common use case for `valid` is checking if the binary format being parsed conforms to a particular version.

[source,javascript]
----
{
  meta: {},
  binary: [
    { type: uint8, id: version, valid: version == 1 }
  ]
}
----

In this case, the `version` field must be 1; otherwise, parsing is stopped.

The variable containing the valid assertion can be referred to explicitly by name or by using the `_` identifier. For example:

[source,javascript]
----
{
  meta: {},
  binary: [
    { type: uint8, id: version, valid: _ == 1 }
  ]
}
----

NOTE: Usage of the `_` identifier in the above context was added in BinDef 0.5

==== `magic` assertions

NOTE: Before BinDef 0.5, magic assertions were covered by a special `magic` type. This type has been removed in version 0.5.

`magic` assertions provide a special mechanism to match file signatures or https://en.wikipedia.org/wiki/File_format#Magic_number[magic numbers]. The difference with these assertions and `valid` assertions is that they are expected to be treated differently by a BinDef runtime on error. For instance, the reference BinDef runtime returns a different error depending on whether a magic assertion or a valid assertion failed.

The following example shows a magic assertion for the signature of a ZIP file format (in this case, the value `PK\x03\x04` at position 0).

[source,javascript]
----
{
  meta: {},
  binary: [
    { type: byte[4], magic: _ == "PK\x03\x04" }
  ]
}
----

The GIF format uses two magic numbers depending on the version: `GIF87a` and `GIF89a`. An assertion matching those values would be:

[source,javascript]
----
{
  meta: {},
  binary: [
    { type: byte[6], magic: _ == "GIF87a" || _ == "GIF89a" }
  ]
}
----

As with valid assertions, the `_` identifier can be used to refer to the parsed value.

=== Conditional fields

Conditional fields allow a BinDef runtime to only process a field if the specified condition is met.

It is possible that a field may only appear if a certain condition is met. For example, our hypothetical file format has a "timestamp" field that is only present when the version is 1.

[source,javascript]
----
{
  meta: {},
  binary: [
    { type: uint8,   id: version },
    { type: int32,   id: timestamp, if: version == 1 },
    { type: byte[4], id: code }
  ]
}
----

Here, `version` being 1 determines whether `timestamp` is parsed before `code` or whether `code` is the next field in the sequence. 

It is worth noting that the `if` condition is checked before processing any other fields, so if the condition is not met, no seek operations or identifier declarations will occur.

=== Unsigned & signed integer types

NOTE: uint24 and int24 were added in version 0.4

The types `uint8`, `uint16`, `uint24`, `uint32`, and `uint64` are used for parsing unsigned integers with those bit sizes. Their signed equivalents are `int8`, `int16`, `int24`, `int32`, and `int64`.

These types must contain an `endian` key specifying either the string "little" or the string "big". This tells BinDef to read the integer in little endian or big endian byte order, respectively. An exception is made for `int8` and `uint8` where specifying a byte endianness is redundant.

=== Floating point types

NOTE: Added in version 0.5

The types `float32` and `float64` are used for parsing IEEE 754 floating point types of single precision (32 bits) and double precision (64 bits) respectively.

As with integer types, floats must also contain an `endian` key specifying either `"little"` or `"big"` as its value.

=== The `byte[n]` type

`byte[n]` tells BinDef to read an arbitrary byte sequence that is `n` bytes long. If only a single byte will be read, the type parameter `n` may be omitted, so `byte` as is can be used.

For example, the Extended Module (xm) format used by some https://en.wikipedia.org/wiki/Music_tracker[music trackers] specifies a 20-byte "module name" at offset 17, after the magic string.

[source,javascript]
----
{
  meta: {},
  binary: [
    { type: byte[17], magic: _ == "Extended Module: " },
    { type: byte[20], id: moduleName, name: "Module name" }
  ]
}
----

A fixed-size string is likely to be padded with whitespace or null bytes in order to fit the size. To remove this padding from the final output, you may specify the `strip` key which is a boolean indicating whether the leading and trailing whitespace of the string must be trimmed.

In the XM format, module names are padded by null bytes or spaces. So, to only get the meaningful part of the string, you can do:

[source,javascript]
----
{ type: byte[20], id: moduleName, name: "Module name", strip: true }
----

Of course, the length of the byte sequence may also be fetched from another identifier. This is useful for type-length-value structures which are fairly common in binary formats.

[source,javascript]
----
{
  meta: {},
  binary: [
    { type: uint16,     id: type, endian: "little" },
    { type: uint16,     id: size, endian: "little" },
    { type: byte[size], id: data }
  ]
}
----

The provided `size` must be a numeric type. If the numeric type is a float, it is truncated and converted to an integer.

=== The `struct` type

NOTE: Added in version 0.2

Structures provide a convenient way of grouping related format fields together. A structure is declared with the `struct` format type and contains a `fields` key which is a list of the format fields that conform the structure.

For example, a file header may be grouped into a structure as follows:

[source,javascript]
----
{
  meta: {},
  binary: [
    { type: struct,
      id: header,
      endian: "little",
      fields: [
        { type: byte[4], magic: _ == "SFF\x00"}, // some file format
        { type: uint8,   id: version },
        { type: uint16,  id: flags },
        { type: uint16,  id: offset },
      ]
    }
  ]
}
----

This encodes a structure containing 4 fields. Note how the structure specifies the `endian` key rather than the fields themselves. If an integer format field does not specify an endianness, it is simply inherited from the parent structure.

Accessing fields in another structure can be done via attribute access syntax (`struct.item`):

[source,javascript]
----
{
  meta: {},
  binary: [
    { type: struct, id: header }, // [...]
    { type: struct, id: block, at: header.offset } // [...]
  ]
}
----

=== The `var` type

NOTE: Added in version 0.3

The `var` type allows definition authors to define values not contained within the binary sequence. This is useful for performing calculations within the document, for providing additional metadata, or for parsing values that are not satisfied by the available format types. 

The `var` type requires an additional field `value` specifying the expression that will be assigned to the variable.

[source,javascript]
----
{
  meta: {},
  binary: [
    { type: uint24, id: intHi, endian: "little" },
    { type: uint24, id: intLo, endian: "little" },
    { type: var,    id: integer, value: (intHi << 24) | intLo }
  ]
}
----

=== The `array[n]` type

NOTE: Added in version 0.3

Most binary formats do not store a single record or element, but rather a collection of them, usually in a sequence starting from a given position. Arrays provide a mechanism for processing a defined amount of elements of the same type within the current binary sequence.

The `array` type requires a type parameter `n` specifying the size of the array. A field using the `array` type requires an additional key `item` specifying the field to be processed `n` times.

If an array is known to extend to the end of the binary sequence (or while a condition is being met, see below), the special identifier `eos` may be specified.

For example, many binary format are conformed of chunks with a type, length, and value, that extend to the end of the file. The following is an example of parsing such a format:

[source,javascript]
----
{ id: chunks,
  type: array[eos],
  item: {
    type: struct, 
    fields: [
      { type: byte[4],      id: type },
      { type: uint32,       id: length, endian: "little" },
      { type: byte[length], id: value }
    ]
  }
}
----

==== The `while` loop

NOTE: Added in version 0.5

Arrays with a dynamic size may specify a `while` key including a condition that must be met while processing the array items. The `while` condition is evaluated before parsing the array item. If the condition is met, another array item is processed; otherwise, if the condition is no longer met, no more items are processed.

One case where `while` can be used is when reading an arbitrary amount of elements given a maximum length. This example defines the "LIST" chunk of a .wav file with a case for handling LIST "INFO" chunks. As only the length is given and not the amount of elements in the INFO chunk, we can keep track of the file position before reading the chunk data, and then using a while condition, check that the file position doesn't exceed the offset that we defined in the `_end` variable.

[source,javascript]
----
{ id: ListChunk, type: struct, endian: "little",
  fields: [        
    { type: uint32,  id: length },

    { type: var,     id: _end, value: filepos + length },

    { type: byte[4], id: type },
    { switch: type,
      cases: {
        "INFO": { while: filepos < _end,
                  type: array[eos], id: data, item: { type: InfoListChunk } }
      },
      default: { type: byte[length], id: data },
    }
  ]
},
----

The purpose of the special variable `filepos` is explained in <<Builtins>>.

=== The `enum` type

NOTE: Added in version 0.4

Enumerations provide a mechanism for defining an integer field that is expected to be a known set of values. The `enum` type takes a single type parameter describing the underlying integer type of the field.

The `enum` type requires an additional key `members` which is a list of mappings described the constant values part of the enumeration.

Each enumeration member is a mapping that must contain the keys `√¨d` and `value`. `id` is an identifier that will be used to refer to the constant value and `value` specifies the constant value itself. Consistent with format types, the keys `name` and `doc` may also be specified.

For example, the Executable and Linkable Format includes multiple integer fields that may be described as enumerations. In this case, we can describe the values of the `e_ident[E_OSABI]` field as shown below.

[source,javascript]
----
{
  type: enum[uint8],
  id: targetABI,
  name: "Target ABI",
  members: [
    { id: SYSTEM_V, value: 0x00, name: "System V" },
    { id: HP_UX,    value: 0x01, name: "HP-UX" },
    { id: NETBSD,   value: 0x02, name: "NetBSD" },
    { id: LINUX,    value: 0x03, name: "Linux" },
    { id: GNU_HURD, value: 0x04, name: "GNU Hurd" },
    // etc.
  ]
}
----

An error must be raised if the specified enum value is outside of the range of the underlying type. An error must also be raised if the processed value (the one read from the binary stream) is not part of the enumeration.

==== Enumeration ranges

NOTE: Added in version 0.5

Enumeration ranges allow a single enum member to specify a range of values that may be assigned to it. An enum range is specified by using a mapping containing the keys `from` and `to` which both define the bounds of the range (inclusive). Of course, the `from` and `to` values are subject to the same bounds as the type.

A common use case for enumeration ranges is specifying reserved or unassigned values.

[source,javascript]
----
{
  type: enum[uint8],
  fields: [
    { id: RESERVED, value: {from: 0, to: 127}, name: "Reserved" },
    { id: APP_1,    value: 128,                name: "Application 1" },
    { id: APP_2,    value: 129,                name: "Application 2" },
    // and so on
  ]
}
----

In this example, all values between 0 and 127 (inclusive) are captured by the `RESERVED` enum member. As 128 is outside of the range, it is captured by the `APP_1` constant.

When referring to the enum constant using a range, you may access the `from` and `to` keys. For example, checking whether a value is in range can be done using `value <= RESERVED.from && value <= RESERVED.to`. 

=== Type definitions

NOTE: Added in version 0.4

Type definitions allow definition authors to separate type structures from the `binary` key making the binary sequence more concise. Type definitions must appear in a separate `types` key within the root of the document.

The structure of a type definition is the same as a format type. However, in type definitions, the `id` key is required as it will be used as the identifier to refer to this type. It is recommended that the keys `at`, `valid`, and `if` do not appear in the root format type.

In the `binary` section, a type defined in `types` can be referred to by name. The contents of the type definition are then inserted into the field.

[source,javascript]
----
{
  meta: {},
  types: [
    { type: struct,
      id: Chunk,
      endian: "little",
      fields: [
        { type: uint16,     id: type },
        { type: uint16,     id: size },
        { type: byte[size], id: data }
      ]
    }
  ],
  binary: [
    { type: Chunk, id: firstChunk }
  ]
}
----

== Statements

NOTE: Added in BinDef 0.5

Statements are mappings that produce a result, usually a format type. Currently, only one statement is available: the `switch` statement.

=== The `switch` statement.

A switch statement produces a result based on a condition and a set of cases. Once the switch condition is evaluated, it is checked with every case specified. If a match is found, it evaluates and returns the type contained in the case; otherwise, if no matches occur, the "default" case is returned if it is present or an error is raised.

The structure of a switch statement is as follows:

[source,javascript]
----
{
  switch: expression,
  cases: {
    case1: expr,
    case2: expr,
    /* ... */
  },
  default: baseCase,  // optional
}
----

As seen above, the switch expression is contained in the `switch` key of the mapping. The `cases` key specifies a mapping of cases that will be matched against the expression.  The `default` key may optionally specify a default expression in the event that none of the cases are matched.

== Builtins

NOTE: Added in version 0.5

Builtins are globally available methods or variables that contain information about the file context as well as utilities that operate on top of that context.

The following builtins are defined:

- `filepos`
- `slice(collection, start, end)`
- `has(collection, element)`
- `len(collection)`
- `ceil(value)`
- `floor(value)`
- `abs(value)`
- `parseInt(string)`

=== filepos

`filepos` is an integer specifying the current byte offset in the file. 

=== slice(collection, start, end)

`slice` returns a subslice of `collection` from index `start` up to index `end`.

`collection` must be either a string or a list. `start` and `end` must be integers.

=== has(collection, element)

`has` reports whether `element` is part of `collection`.

`collection` must be a list. `element` may be any valid type.

=== len(collection)

`len` determines the length of `collection`.

- If `collection` is a string, `len` returns the number of bytes in the string.
- If `collection` is a mapping, `len` returns the number of keys in the mapping.
- If `collection` is a list, `len` returns the number of elements in the list.

=== ceil(value)

`ceil` returns the ceiling of `value`. `value` must be numeric (either an integer or a float).

=== floor(value)

`floor` returns the floor of `value`. `value` must be numeric (either an integer or a float).

=== abs(value)

`abs` returns the absolute value of `value`. `value` must be numeric (either an integer or a float).

=== parseInt(value)

`parseInt` converts a string `value` into an integer. The entire string must be composed of digits 0 through 9. The string will be interpreted as a base 10 integer.

== Versioning

BinDef versions follow the `X.Y` format where `X` is the major version and `Y` is the minor version. 

The **major version** is incremented by 1 when a _breaking change_ occurs, that is, a change that may break compatibility with a BinDef processor supporting an older major version. For example, new syntax or removal of a field would constitute a major version increase.  

The **minor version** is incremented by 1 when a _backwards compatible change_ occurs, that is, a change that does not affect compatibility with a BinDef processor supporting the same major version but an older minor version. Minor versions are usually small revisions and patches, deprecations, or new features that don't introduce new syntax.

A special exception to this is when the major version is zero; in such case, the minor version should be treated as the major version. No compatibility guarantees are made between `0.X` releases.

When the major version is incremented, the minor version resets to 0. 

When a BinDef processor encounters a document specifying a greater major version than it can process, it shall raise an error. When a BinDef processor encounters a document specifying a greater minor version than it expects, it shall continue parsing the document but may raise a warning if appropriate.
